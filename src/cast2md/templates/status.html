{% extends "base.html" %}

{% block title %}Status - cast2md{% endblock %}

{% block content %}
<div class="page-header">
    <hgroup>
        <h1>System Status</h1>
        <p>Overview of episode processing</p>
    </hgroup>
    <div class="header-actions">
        <button onclick="queueAllPending()">Queue All Pending</button>
        <button class="secondary" onclick="cancelAllQueued()">Cancel All Queued</button>
    </div>
</div>

<div class="stats-grid">
    <div class="stat-card">
        <h3>{{ feed_count }}</h3>
        <p>Feeds</p>
    </div>
    <div class="stat-card">
        <h3>{{ status_counts.get('new', 0) }}</h3>
        <p>New</p>
    </div>
    <div class="stat-card">
        <h3>{{ queue_status.download_queue.queued + queue_status.transcribe_queue.queued }}</h3>
        <p>Queued</p>
    </div>
    <div class="stat-card">
        <h3>{{ queue_status.download_queue.running + queue_status.transcribe_queue.running }}</h3>
        <p>Running</p>
    </div>
    <div class="stat-card">
        <h3>{{ status_counts.get('completed', 0) }}</h3>
        <p>Completed</p>
    </div>
    <div class="stat-card">
        <h3>{{ status_counts.get('failed', 0) }}</h3>
        <p>Failed</p>
    </div>
</div>

<!-- Active Workers -->
<article>
    <header>
        <h3>Active Workers
            {% if queue_status.running %}
            <span class="status-badge status-completed">Running</span>
            {% else %}
            <span class="status-badge status-failed">Stopped</span>
            {% endif %}
        </h3>
    </header>
    <table>
        <thead>
            <tr>
                <th>Worker</th>
                <th>Status</th>
                <th>Current Job</th>
                <th>Progress</th>
            </tr>
        </thead>
        <tbody>
            {% for worker in workers %}
            <tr>
                <td>{{ worker.name }}</td>
                <td>
                    {% if worker.status == 'busy' %}
                    <span class="status-badge status-downloading">busy</span>
                    {% elif worker.status == 'online' %}
                    <span class="status-badge status-completed">online</span>
                    {% elif worker.status == 'offline' %}
                    <span class="status-badge status-failed">offline</span>
                    {% elif worker.status == 'stuck' %}
                    <span class="status-badge status-failed">stuck</span>
                    {% else %}
                    <span class="status-badge status-new">idle</span>
                    {% endif %}
                </td>
                <td>
                    {% if worker.type == 'transcript_download_summary' %}
                    {{ worker.active_count }}/{{ worker.total_count }} active
                    {% elif worker.episode %}
                    <a href="/episodes/{{ worker.episode.id }}">{{ worker.episode.title[:40] }}{% if worker.episode.title|length > 40 %}...{% endif %}</a>
                    {% else %}
                    -
                    {% endif %}
                </td>
                <td>
                    {% if worker.type == 'transcript_download_summary' %}
                    -
                    {% elif worker.status == 'stuck' %}
                    <span style="color: var(--pico-del-color);">needs cancellation</span>
                    {% elif worker.progress is not none %}
                    <div class="progress-container">
                        <progress value="{{ worker.progress }}" max="100"></progress>
                        <small class="progress-text">{{ worker.progress }}%</small>
                        {% if worker.job and worker.job.started_at %}
                            {% if worker.progress > 0 %}
                        <small class="remaining" data-started="{{ worker.job.started_at.isoformat() }}Z" data-progress="{{ worker.progress }}"></small>
                            {% else %}
                        <small class="elapsed" data-started="{{ worker.job.started_at.isoformat() }}Z"></small>
                            {% endif %}
                        {% endif %}
                    </div>
                    {% elif worker.status == 'busy' %}
                    <div class="progress-container">
                        <progress class="indeterminate"></progress>
                        {% if worker.job and worker.job.started_at %}
                        <small class="elapsed" data-started="{{ worker.job.started_at.isoformat() }}Z"></small>
                        {% endif %}
                    </div>
                    {% else %}
                    -
                    {% endif %}
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</article>

{% if queued_downloads %}
<article>
    <header><h3>Download Queue ({{ queued_downloads|length }})</h3></header>
    <table>
        <thead>
            <tr><th>Episode</th><th style="width: 12rem;">Actions</th></tr>
        </thead>
        <tbody>
            {% for item in queued_downloads %}
            <tr>
                <td><a href="/episodes/{{ item.episode.id }}">{{ item.episode.title }}</a></td>
                <td><div class="actions"><button class="outline secondary" onclick="cancelJob({{ item.job.id }})">Cancel</button></div></td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</article>
{% endif %}

{% if queued_transcriptions %}
<article>
    <header><h3>Transcription Queue ({{ queued_transcriptions|length }})</h3></header>
    <table>
        <thead>
            <tr><th>Episode</th><th style="width: 12rem;">Actions</th></tr>
        </thead>
        <tbody>
            {% for item in queued_transcriptions %}
            <tr>
                <td><a href="/episodes/{{ item.episode.id }}">{{ item.episode.title }}</a></td>
                <td><div class="actions"><button class="outline secondary" onclick="cancelJob({{ item.job.id }})">Cancel</button></div></td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</article>
{% endif %}

{% if downloaded %}
<article>
    <header><h3>Ready for Transcription ({{ downloaded|length }})</h3></header>
    <table>
        <thead>
            <tr><th>Episode</th><th style="width: 12rem;">Actions</th></tr>
        </thead>
        <tbody>
            {% for ep in downloaded %}
            <tr>
                <td><a href="/episodes/{{ ep.id }}">{{ ep.title }}</a></td>
                <td><div class="actions"><button class="outline" onclick="queueTranscribe({{ ep.id }})">Queue Transcription</button></div></td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</article>
{% endif %}

{% if failed %}
<article>
    <header><h3>Failed ({{ failed|length }})</h3></header>
    <table>
        <thead>
            <tr><th>Episode</th><th>Error</th><th style="width: 12rem;">Actions</th></tr>
        </thead>
        <tbody>
            {% for ep in failed %}
            <tr>
                <td><a href="/episodes/{{ ep.id }}">{{ ep.title }}</a></td>
                <td class="truncate">{{ ep.error_message or 'Unknown error' }}</td>
                <td><div class="actions"><button class="outline secondary" onclick="queueProcess({{ ep.id }})">Retry</button></div></td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</article>
{% endif %}

{% if pending %}
<article>
    <header><h3>Pending Download (showing {{ pending|length }})</h3></header>
    <table>
        <thead>
            <tr><th>Episode</th><th style="width: 12rem;">Actions</th></tr>
        </thead>
        <tbody>
            {% for ep in pending %}
            <tr>
                <td><a href="/episodes/{{ ep.id }}">{{ ep.title }}</a></td>
                <td><div class="actions"><button class="outline" onclick="queueProcess({{ ep.id }})">Queue Download</button></div></td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</article>
{% endif %}
{% endblock %}

{% block scripts %}
<script>
// Format time duration
function formatDuration(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    if (h > 0) return `${h}h ${m}m`;
    if (m > 0) return `${m}m ${s}s`;
    return `${s}s`;
}

function updateElapsedTimes() {
    // Update elapsed time for indeterminate progress
    document.querySelectorAll('.elapsed').forEach(el => {
        const started = new Date(el.dataset.started);
        const elapsed = (Date.now() - started.getTime()) / 1000;
        el.textContent = formatDuration(elapsed);
    });

    // Update remaining time for jobs with progress
    document.querySelectorAll('.remaining').forEach(el => {
        const started = new Date(el.dataset.started);
        const progress = parseFloat(el.dataset.progress);
        if (progress > 0) {
            const elapsed = (Date.now() - started.getTime()) / 1000;
            const totalEstimate = elapsed / (progress / 100);
            const remaining = totalEstimate - elapsed;
            if (remaining > 0) {
                el.textContent = '~' + formatDuration(remaining) + ' left';
            } else {
                el.textContent = 'finishing...';
            }
        }
    });
}

updateElapsedTimes();
setInterval(updateElapsedTimes, 1000);

// Convert UTC timestamps to local time
function updateLocalTimes() {
    document.querySelectorAll('.local-time').forEach(el => {
        const utc = el.dataset.utc;
        if (utc) {
            const date = new Date(utc + (utc.endsWith('Z') ? '' : 'Z'));
            const now = new Date();
            const diff = Math.floor((now - date) / 1000);
            if (diff < 60) {
                el.textContent = `${diff}s ago`;
            } else if (diff < 3600) {
                el.textContent = `${Math.floor(diff / 60)}m ago`;
            } else {
                el.textContent = date.toLocaleTimeString();
            }
        }
    });
}
updateLocalTimes();
setInterval(updateLocalTimes, 5000);

async function queueProcess(episodeId) {
    try {
        const response = await fetch(`/api/queue/episodes/${episodeId}/process`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            window.location.reload();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function queueTranscribe(episodeId) {
    try {
        const response = await fetch(`/api/queue/episodes/${episodeId}/transcribe`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            window.location.reload();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function cancelJob(jobId) {
    if (!confirm('Cancel this job?')) {
        return;
    }

    try {
        const response = await fetch(`/api/queue/${jobId}`, {method: 'DELETE'});
        const data = await response.json();

        if (response.ok) {
            window.location.reload();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function queueAllPending() {
    if (!confirm('Queue all new episodes for processing?')) {
        return;
    }

    try {
        const response = await fetch('/api/queue/batch/all/process', {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            setTimeout(() => window.location.reload(), 1500);
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function cancelAllQueued() {
    if (!confirm('Cancel all queued jobs?')) {
        return;
    }

    try {
        const response = await fetch('/api/queue/batch/queued', {method: 'DELETE'});
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            setTimeout(() => window.location.reload(), 1500);
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

// Auto-refresh every 10 seconds if there are running jobs
{% if running_downloads or running_transcriptions or queued_downloads or queued_transcriptions %}
setTimeout(() => window.location.reload(), 10000);
{% endif %}
</script>
{% endblock %}
