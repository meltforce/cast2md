{% extends "base.html" %}

{% block title %}Settings - cast2md{% endblock %}

{% block content %}
<hgroup>
    <h1>Settings</h1>
    <p>Configure worker counts and storage paths</p>
</hgroup>

<article>
    <header>
        <h3>Configuration</h3>
    </header>

    <form id="settingsForm">
        <!-- Form fields will be populated dynamically -->
        <div id="settingsFields"></div>

        <div style="display: flex; gap: 1rem; margin-top: 1rem;">
            <button type="submit">Save Settings</button>
            <button type="button" class="secondary" onclick="resetAllSettings()">Reset to Defaults</button>
            <button type="button" class="outline" onclick="testNotification()">Test Notification</button>
        </div>
    </form>

    <footer>
        <small>Note: Some settings require a server restart to take effect.</small>
    </footer>
</article>

<article>
    <header>
        <h3>Current Values</h3>
    </header>
    <table id="currentSettings">
        <thead>
            <tr>
                <th>Setting</th>
                <th>Value</th>
                <th>Source</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <!-- Populated by JavaScript -->
        </tbody>
    </table>
</article>

<article>
    <header>
        <h3>Whisper Models</h3>
    </header>

    <table id="modelsTable">
        <thead>
            <tr>
                <th>Model ID</th>
                <th>Backend</th>
                <th>Description</th>
                <th>Size</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <!-- Populated by JavaScript -->
        </tbody>
    </table>

    <details style="margin-top: 1rem;">
        <summary>Add Custom Model</summary>
        <form id="addModelForm" style="margin-top: 1rem;">
            <div class="grid">
                <label>
                    Model ID
                    <input type="text" name="id" required placeholder="e.g., distil-large-v3">
                </label>
                <label>
                    Backend
                    <select name="backend">
                        <option value="both">both</option>
                        <option value="faster-whisper">faster-whisper</option>
                        <option value="mlx">mlx</option>
                    </select>
                </label>
            </div>
            <div class="grid">
                <label>
                    HuggingFace Repo (for mlx)
                    <input type="text" name="hf_repo" placeholder="e.g., mlx-community/whisper-...">
                </label>
                <label>
                    Size (MB)
                    <input type="number" name="size_mb" placeholder="optional">
                </label>
            </div>
            <label>
                Description
                <input type="text" name="description" placeholder="optional">
            </label>
            <button type="submit">Add Model</button>
        </form>
    </details>

    <div style="margin-top: 1rem;">
        <button class="secondary outline" onclick="resetModels()">Reset to Default Models</button>
    </div>
</article>

<article>
    <header>
        <h3>Transcriber Nodes</h3>
    </header>

    <p>Remote nodes can process transcription jobs in parallel with this server.
       Enable distributed transcription in settings above to use this feature.</p>

    <table id="nodesTable">
        <thead>
            <tr>
                <th>Name</th>
                <th>Status</th>
                <th>Model</th>
                <th>Last Heartbeat</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <!-- Populated by JavaScript -->
        </tbody>
    </table>

    <details style="margin-top: 1rem;">
        <summary>Add Node Manually</summary>
        <form id="addNodeForm" style="margin-top: 1rem;">
            <div class="grid">
                <label>
                    Name
                    <input type="text" name="name" required placeholder="e.g., M4 MacBook Pro">
                </label>
                <label>
                    URL
                    <input type="text" name="url" required placeholder="e.g., http://192.168.1.100:8001">
                </label>
            </div>
            <div class="grid">
                <label>
                    Whisper Model (optional)
                    <input type="text" name="whisper_model" placeholder="e.g., large-v3-turbo">
                </label>
                <label>
                    Priority
                    <input type="number" name="priority" value="10" min="1" max="100">
                </label>
            </div>
            <button type="submit">Add Node</button>
        </form>
    </details>
</article>
{% endblock %}

{% block scripts %}
<script>
let currentSettings = {};

async function loadSettings() {
    try {
        const response = await fetch('/api/settings');
        const data = await response.json();
        currentSettings = data.settings;

        // Build form fields dynamically
        const fieldsContainer = document.getElementById('settingsFields');
        fieldsContainer.innerHTML = '';

        const entries = Object.entries(currentSettings);
        let html = '';
        let inGrid = false;
        let gridCount = 0;

        entries.forEach(([key, info], index) => {
            let inputHtml = '';
            const isBool = info.type === 'bool';
            const isChecked = info.value === true || info.value === 'true' || info.value === '1';
            const isFullWidth = info.full_width === true;

            if (info.type === 'int') {
                inputHtml = `<input type="number" name="${key}" id="${key}"
                    min="${info.min || ''}" max="${info.max || ''}" value="${info.value}">`;
            } else if (info.type === 'select') {
                const options = info.options.map(opt =>
                    `<option value="${opt}" ${info.value === opt ? 'selected' : ''}>${opt}</option>`
                ).join('');
                inputHtml = `<select name="${key}" id="${key}">${options}</select>`;
            } else if (info.type === 'bool') {
                inputHtml = `<input type="checkbox" name="${key}" id="${key}" value="true" ${isChecked ? 'checked' : ''} role="switch">`;
            } else {
                inputHtml = `<input type="text" name="${key}" id="${key}" value="${info.value || ''}">`;
            }

            // Handle full-width items - close current grid if open
            if (isFullWidth && inGrid) {
                html += '</div>';
                inGrid = false;
                gridCount = 0;
            }

            // Start a new grid if needed for non-full-width items
            if (!isFullWidth && !inGrid) {
                html += '<div class="grid">';
                inGrid = true;
                gridCount = 0;
            }

            html += `
                <label${isBool ? ' style="display: flex; align-items: center; gap: 0.5rem;"' : ''}>
                    ${isBool ? inputHtml + ' ' + info.label : info.label + inputHtml}
                    ${isBool ? '' : '<small>' + info.description + '</small>'}
                </label>
                ${isBool ? '<small style="margin-top: -0.75rem; margin-bottom: 0.5rem;">' + info.description + '</small>' : ''}
            `;

            if (!isFullWidth) {
                gridCount++;
                // Close grid after 2 items
                if (gridCount === 2) {
                    html += '</div>';
                    inGrid = false;
                    gridCount = 0;
                }
            }
        });

        // Close any open grid
        if (inGrid) {
            html += '</div>';
        }

        fieldsContainer.innerHTML = html;

        // Populate current values table
        const tbody = document.querySelector('#currentSettings tbody');
        tbody.innerHTML = '';

        for (const [key, info] of Object.entries(currentSettings)) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>
                    <strong>${info.label}</strong><br>
                    <small>${info.description}</small>
                </td>
                <td><code>${info.value}</code></td>
                <td>
                    <span class="status-badge ${info.source === 'database' ? 'status-completed' : 'status-pending'}">
                        ${info.source}
                    </span>
                </td>
                <td>
                    ${info.has_override ? `<button class="outline secondary" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;" onclick="resetSetting('${key}')">Reset</button>` : ''}
                </td>
            `;
            tbody.appendChild(row);
        }
    } catch (error) {
        alert('Error loading settings: ' + error.message);
    }
}

document.getElementById('settingsForm').addEventListener('submit', async (e) => {
    e.preventDefault();

    const formData = new FormData(e.target);
    const settings = {};

    // Handle all fields, including unchecked checkboxes
    for (const [key, info] of Object.entries(currentSettings)) {
        if (info.type === 'bool') {
            settings[key] = formData.has(key) ? 'true' : 'false';
        } else {
            const value = formData.get(key);
            if (value !== null) {
                settings[key] = value;
            }
        }
    }

    try {
        const response = await fetch('/api/settings', {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({settings})
        });
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            loadSettings();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error saving settings: ' + error.message);
    }
});

async function resetSetting(key) {
    if (!confirm(`Reset '${currentSettings[key]?.label || key}' to default?`)) {
        return;
    }

    try {
        const response = await fetch(`/api/settings/${key}`, {method: 'DELETE'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            loadSettings();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function resetAllSettings() {
    if (!confirm('Reset all settings to defaults?')) {
        return;
    }

    try {
        const response = await fetch('/api/settings', {method: 'DELETE'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            loadSettings();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function testNotification() {
    try {
        const response = await fetch('/api/settings/notifications/test', {method: 'POST'});
        const data = await response.json();
        alert(data.message);
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Models management
async function loadModels() {
    try {
        const response = await fetch('/api/settings/models');
        const data = await response.json();

        const tbody = document.querySelector('#modelsTable tbody');
        tbody.innerHTML = '';

        for (const model of data.models) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><code>${model.id}</code></td>
                <td>${model.backend}</td>
                <td>${model.description || '-'}</td>
                <td>${model.size_mb ? model.size_mb + ' MB' : '-'}</td>
                <td>
                    <button class="outline secondary" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;"
                            onclick="deleteModel('${model.id}')">Delete</button>
                </td>
            `;
            tbody.appendChild(row);
        }
    } catch (error) {
        console.error('Error loading models:', error);
    }
}

document.getElementById('addModelForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    const model = {
        id: formData.get('id'),
        backend: formData.get('backend'),
        hf_repo: formData.get('hf_repo') || null,
        description: formData.get('description') || null,
        size_mb: formData.get('size_mb') ? parseInt(formData.get('size_mb')) : null,
    };

    try {
        const response = await fetch('/api/settings/models', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(model)
        });
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            e.target.reset();
            loadModels();
            loadSettings(); // Refresh settings to update model dropdown
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
});

async function deleteModel(modelId) {
    if (!confirm(`Delete model '${modelId}'?`)) {
        return;
    }

    try {
        const response = await fetch(`/api/settings/models/${modelId}`, {method: 'DELETE'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            loadModels();
            loadSettings();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function resetModels() {
    if (!confirm('Reset to default models? This will remove all custom models.')) {
        return;
    }

    try {
        const response = await fetch('/api/settings/models/reset', {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            loadModels();
            loadSettings();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Nodes management
async function loadNodes() {
    try {
        const response = await fetch('/api/nodes');
        const data = await response.json();

        const tbody = document.querySelector('#nodesTable tbody');
        tbody.innerHTML = '';

        if (data.nodes.length === 0) {
            const row = document.createElement('tr');
            row.innerHTML = '<td colspan="5" style="text-align: center;">No nodes registered</td>';
            tbody.appendChild(row);
            return;
        }

        for (const node of data.nodes) {
            const row = document.createElement('tr');
            const lastHeartbeat = node.last_heartbeat
                ? new Date(node.last_heartbeat).toLocaleString()
                : 'Never';

            let statusClass = 'status-pending';
            if (node.status === 'online') statusClass = 'status-completed';
            else if (node.status === 'busy') statusClass = 'status-downloading';
            else if (node.status === 'offline') statusClass = 'status-failed';

            row.innerHTML = `
                <td><strong>${node.name}</strong><br><small><code>${node.id.slice(0, 8)}...</code></small></td>
                <td><span class="status-badge ${statusClass}">${node.status}</span></td>
                <td>${node.whisper_model || '-'}</td>
                <td>${lastHeartbeat}</td>
                <td>
                    <button class="outline secondary" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;"
                            onclick="testNode('${node.id}')">Test</button>
                    <button class="outline secondary" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;"
                            onclick="deleteNode('${node.id}')">Delete</button>
                </td>
            `;
            tbody.appendChild(row);
        }
    } catch (error) {
        console.error('Error loading nodes:', error);
    }
}

document.getElementById('addNodeForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    const node = {
        name: formData.get('name'),
        url: formData.get('url'),
        whisper_model: formData.get('whisper_model') || null,
        priority: parseInt(formData.get('priority')) || 10,
    };

    try {
        const response = await fetch('/api/nodes', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(node)
        });
        const data = await response.json();

        if (response.ok) {
            alert(`Node added! API Key: ${data.api_key}\n\nSave this key - it won't be shown again.`);
            e.target.reset();
            loadNodes();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
});

async function testNode(nodeId) {
    try {
        const response = await fetch(`/api/nodes/${nodeId}/test`, {method: 'POST'});
        const data = await response.json();
        alert(data.message);
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function deleteNode(nodeId) {
    if (!confirm('Delete this node?')) {
        return;
    }

    try {
        const response = await fetch(`/api/nodes/${nodeId}`, {method: 'DELETE'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            loadNodes();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Load settings, models, and nodes on page load
loadSettings();
loadModels();
loadNodes();
</script>
{% endblock %}
