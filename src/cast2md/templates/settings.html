{% extends "base.html" %}

{% block title %}Settings - cast2md{% endblock %}

{% block content %}
<div class="page-header">
    <hgroup>
        <h1>Settings</h1>
        <p>Configure storage, transcription, and workers</p>
    </hgroup>
    <div class="header-actions">
        <button type="submit" form="settingsForm" style="width: auto;">Save</button>
        <button type="button" class="secondary" style="width: auto;" onclick="resetAllSettings()">Reset All</button>
    </div>
</div>

<form id="settingsForm">

<!-- Storage -->
<article>
    <header>
        <h3 style="margin: 0;">Storage</h3>
    </header>
    <div id="storageFields" class="grid"></div>
</article>

<!-- Transcription -->
<article>
    <header style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
        <h3 style="margin: 0;">Transcription</h3>
        <button type="button" class="outline secondary" onclick="resetModels()">Reset Models</button>
    </header>
    <div id="transcriptionFields" class="grid"></div>

    <details style="margin-top: 1rem;">
        <summary>Available Models</summary>
        <table id="modelsTable" style="margin-top: 0.5rem;">
            <thead>
                <tr>
                    <th>Model ID</th>
                    <th>Backend</th>
                    <th>Description</th>
                    <th>Size</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                <!-- Populated by JavaScript -->
            </tbody>
        </table>
    </details>

    <details>
        <summary>Add Custom Model</summary>
        <div style="margin-top: 1rem;">
            <div class="grid">
                <label>
                    Model ID
                    <input type="text" id="newModelId" placeholder="e.g., distil-large-v3">
                </label>
                <label>
                    Backend
                    <select id="newModelBackend">
                        <option value="both">both</option>
                        <option value="faster-whisper">faster-whisper</option>
                        <option value="mlx">mlx</option>
                    </select>
                </label>
            </div>
            <div class="grid">
                <label>
                    HuggingFace Repo (for mlx)
                    <input type="text" id="newModelHfRepo" placeholder="e.g., mlx-community/whisper-...">
                </label>
                <label>
                    Size (MB)
                    <input type="number" id="newModelSize" placeholder="optional">
                </label>
            </div>
            <label>
                Description
                <input type="text" id="newModelDesc" placeholder="optional">
            </label>
            <button type="button" onclick="addModel()">Add Model</button>
        </div>
    </details>
</article>

<!-- Workers -->
<article>
    <header>
        <h3 style="margin: 0;">Workers</h3>
    </header>
    <div id="workersFields" class="grid"></div>
</article>

<!-- Notifications -->
<article>
    <header style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
        <h3 style="margin: 0;">Notifications</h3>
        <button type="button" class="outline secondary" onclick="testNotification()">Test</button>
    </header>
    <div id="notificationsFields"></div>
</article>

<!-- Distributed Transcription -->
<article>
    <header>
        <h3 style="margin: 0;">Distributed Transcription</h3>
    </header>
    <div id="distributedFields"></div>

    <table id="nodesTable" style="margin-top: 1rem;">
        <thead>
            <tr>
                <th>Name</th>
                <th>Status</th>
                <th>Model</th>
                <th>Last Heartbeat</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <!-- Populated by JavaScript -->
        </tbody>
    </table>

    <details style="margin-top: 1rem;">
        <summary>Add Node Manually</summary>
        <div style="margin-top: 1rem;">
            <div class="grid">
                <label>
                    Name
                    <input type="text" id="newNodeName" placeholder="e.g., M4 MacBook Pro">
                </label>
                <label>
                    URL
                    <input type="text" id="newNodeUrl" placeholder="e.g., http://192.168.1.100:8001">
                </label>
            </div>
            <div class="grid">
                <label>
                    Whisper Model (optional)
                    <input type="text" id="newNodeModel" placeholder="e.g., large-v3-turbo">
                </label>
                <label>
                    Priority
                    <input type="number" id="newNodePriority" value="10" min="1" max="100">
                </label>
            </div>
            <button type="button" onclick="addNode()">Add Node</button>
        </div>
    </details>
</article>

<!-- General -->
<article>
    <header>
        <h3 style="margin: 0;">General</h3>
    </header>
    <div id="generalFields" class="grid"></div>
</article>

</form>

<!-- Current Values (reference) -->
<article>
    <header>
        <h3 style="margin: 0;">Current Values</h3>
    </header>
    <table id="currentSettings">
        <thead>
            <tr>
                <th>Setting</th>
                <th>Value</th>
                <th>Source</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <!-- Populated by JavaScript -->
        </tbody>
    </table>
</article>
{% endblock %}

{% block scripts %}
<script>
let currentSettings = {};

// Map settings to their sections
const settingSections = {
    'storage_path': 'storage',
    'temp_download_path': 'storage',
    'whisper_model': 'transcription',
    'whisper_backend': 'transcription',
    'max_concurrent_downloads': 'workers',
    'max_transcript_download_workers': 'workers',
    'stuck_threshold_hours': 'workers',
    'transcript_unavailable_age_days': 'workers',
    'ntfy_enabled': 'notifications',
    'ntfy_url': 'notifications',
    'ntfy_topic': 'notifications',
    'distributed_transcription_enabled': 'distributed',
    'node_heartbeat_timeout_seconds': 'distributed',
    'remote_job_timeout_hours': 'distributed',
    'itunes_country': 'general',
};

const sectionContainers = {
    'storage': 'storageFields',
    'transcription': 'transcriptionFields',
    'workers': 'workersFields',
    'notifications': 'notificationsFields',
    'distributed': 'distributedFields',
    'general': 'generalFields',
};

async function loadSettings() {
    try {
        const response = await fetch('/api/settings');
        const data = await response.json();
        currentSettings = data.settings;

        // Clear all section containers
        Object.values(sectionContainers).forEach(id => {
            document.getElementById(id).innerHTML = '';
        });

        // Group settings by section
        const sections = {};
        for (const [key, info] of Object.entries(currentSettings)) {
            const section = settingSections[key] || 'general';
            if (!sections[section]) sections[section] = [];
            sections[section].push({ key, info });
        }

        // Render each section
        for (const [section, settings] of Object.entries(sections)) {
            const containerId = sectionContainers[section];
            const container = document.getElementById(containerId);
            if (!container) continue;

            let html = '';
            let needsGrid = section !== 'notifications' && section !== 'distributed';

            settings.forEach(({ key, info }) => {
                const isBool = info.type === 'bool';
                const isChecked = info.value === true || info.value === 'true' || info.value === '1';

                let inputHtml = '';
                if (info.type === 'int') {
                    inputHtml = `<input type="number" name="${key}" id="${key}" min="${info.min || ''}" max="${info.max || ''}" value="${info.value}">`;
                } else if (info.type === 'select') {
                    const options = info.options.map(opt =>
                        `<option value="${opt}" ${info.value === opt ? 'selected' : ''}>${opt}</option>`
                    ).join('');
                    inputHtml = `<select name="${key}" id="${key}">${options}</select>`;
                } else if (info.type === 'bool') {
                    inputHtml = `<input type="checkbox" name="${key}" id="${key}" value="true" ${isChecked ? 'checked' : ''} role="switch">`;
                } else {
                    inputHtml = `<input type="text" name="${key}" id="${key}" value="${info.value || ''}">`;
                }

                if (isBool) {
                    html += `
                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                            ${inputHtml} ${info.label}
                        </label>
                        <small style="margin-top: -0.5rem; margin-bottom: 1rem; display: block;">${info.description}</small>
                    `;
                } else {
                    html += `
                        <label>
                            ${info.label}
                            ${inputHtml}
                            <small>${info.description}</small>
                        </label>
                    `;
                }
            });

            container.innerHTML = html;
        }

        // Populate current values table
        const tbody = document.querySelector('#currentSettings tbody');
        tbody.innerHTML = '';

        for (const [key, info] of Object.entries(currentSettings)) {
            const row = document.createElement('tr');

            let sourceClass = 'status-new';
            if (info.source === 'database') sourceClass = 'status-completed';
            else if (info.source === 'env_file') sourceClass = 'status-downloading';

            const hasDbValue = info.db_value !== null && info.db_value !== undefined;

            row.innerHTML = `
                <td>
                    <strong>${info.label}</strong><br>
                    <small>${info.description}</small>
                </td>
                <td><code>${info.value}</code></td>
                <td><span class="status-badge ${sourceClass}">${info.source}</span></td>
                <td>
                    ${hasDbValue ? `<button type="button" class="outline secondary" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;" onclick="resetSetting('${key}')">Reset</button>` : ''}
                </td>
            `;
            tbody.appendChild(row);
        }
    } catch (error) {
        showError('Error loading settings: ' + error.message);
    }
}

document.getElementById('settingsForm').addEventListener('submit', async (e) => {
    e.preventDefault();

    const formData = new FormData(e.target);
    const settings = {};

    for (const [key, info] of Object.entries(currentSettings)) {
        if (info.type === 'bool') {
            settings[key] = formData.has(key) ? 'true' : 'false';
        } else {
            const value = formData.get(key);
            if (value !== null) {
                settings[key] = value;
            }
        }
    }

    try {
        const response = await fetch('/api/settings', {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({settings})
        });
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            loadSettings();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError('Error saving settings: ' + error.message);
    }
});

async function resetSetting(key) {
    if (!confirm(`Reset '${currentSettings[key]?.label || key}' to default?`)) return;

    try {
        const response = await fetch(`/api/settings/${key}`, {method: 'DELETE'});
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            loadSettings();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function resetAllSettings() {
    if (!confirm('Reset all settings to defaults?')) return;

    try {
        const response = await fetch('/api/settings', {method: 'DELETE'});
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            loadSettings();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function testNotification() {
    try {
        const response = await fetch('/api/settings/notifications/test', {method: 'POST'});
        const data = await response.json();
        showInfo(data.message);
    } catch (error) {
        showError(error.message);
    }
}

// Models management
async function loadModels() {
    try {
        const response = await fetch('/api/settings/models');
        const data = await response.json();

        const tbody = document.querySelector('#modelsTable tbody');
        tbody.innerHTML = '';

        for (const model of data.models) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><code>${model.id}</code></td>
                <td>${model.backend}</td>
                <td>${model.description || '-'}</td>
                <td>${model.size_mb ? model.size_mb + ' MB' : '-'}</td>
                <td>
                    <button type="button" class="outline secondary" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;"
                            onclick="deleteModel('${model.id}')">Delete</button>
                </td>
            `;
            tbody.appendChild(row);
        }
    } catch (error) {
        console.error('Error loading models:', error);
    }
}

async function addModel() {
    const model = {
        id: document.getElementById('newModelId').value,
        backend: document.getElementById('newModelBackend').value,
        hf_repo: document.getElementById('newModelHfRepo').value || null,
        description: document.getElementById('newModelDesc').value || null,
        size_mb: document.getElementById('newModelSize').value ? parseInt(document.getElementById('newModelSize').value) : null,
    };

    if (!model.id) {
        showError('Model ID is required');
        return;
    }

    try {
        const response = await fetch('/api/settings/models', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(model)
        });
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            document.getElementById('newModelId').value = '';
            document.getElementById('newModelHfRepo').value = '';
            document.getElementById('newModelDesc').value = '';
            document.getElementById('newModelSize').value = '';
            loadModels();
            loadSettings();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function deleteModel(modelId) {
    if (!confirm(`Delete model '${modelId}'?`)) return;

    try {
        const response = await fetch(`/api/settings/models/${modelId}`, {method: 'DELETE'});
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            loadModels();
            loadSettings();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function resetModels() {
    if (!confirm('Reset to default models? This will remove all custom models.')) return;

    try {
        const response = await fetch('/api/settings/models/reset', {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            loadModels();
            loadSettings();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

// Nodes management
async function loadNodes() {
    try {
        const response = await fetch('/api/nodes');
        const data = await response.json();

        const tbody = document.querySelector('#nodesTable tbody');
        tbody.innerHTML = '';

        if (data.nodes.length === 0) {
            const row = document.createElement('tr');
            row.innerHTML = '<td colspan="5" style="text-align: center; color: var(--pico-muted-color);">No nodes registered</td>';
            tbody.appendChild(row);
            return;
        }

        for (const node of data.nodes) {
            const row = document.createElement('tr');
            const lastHeartbeat = node.last_heartbeat
                ? new Date(node.last_heartbeat).toLocaleString()
                : 'Never';

            let statusClass = 'status-new';
            if (node.status === 'online') statusClass = 'status-completed';
            else if (node.status === 'busy') statusClass = 'status-downloading';
            else if (node.status === 'offline') statusClass = 'status-failed';

            row.innerHTML = `
                <td><strong>${node.name}</strong><br><small><code>${node.id.slice(0, 8)}...</code></small></td>
                <td><span class="status-badge ${statusClass}">${node.status}</span></td>
                <td>${node.whisper_model || '-'}</td>
                <td>${lastHeartbeat}</td>
                <td>
                    <button type="button" class="outline secondary" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;"
                            onclick="testNode('${node.id}')">Test</button>
                    <button type="button" class="outline secondary" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;"
                            onclick="deleteNode('${node.id}')">Delete</button>
                </td>
            `;
            tbody.appendChild(row);
        }
    } catch (error) {
        console.error('Error loading nodes:', error);
    }
}

async function addNode() {
    const node = {
        name: document.getElementById('newNodeName').value,
        url: document.getElementById('newNodeUrl').value,
        whisper_model: document.getElementById('newNodeModel').value || null,
        priority: parseInt(document.getElementById('newNodePriority').value) || 10,
    };

    if (!node.name || !node.url) {
        showError('Name and URL are required');
        return;
    }

    try {
        const response = await fetch('/api/nodes', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(node)
        });
        const data = await response.json();

        if (response.ok) {
            showSuccess(`Node added! API Key: ${data.api_key} - Save this key, it won't be shown again.`);
            document.getElementById('newNodeName').value = '';
            document.getElementById('newNodeUrl').value = '';
            document.getElementById('newNodeModel').value = '';
            document.getElementById('newNodePriority').value = '10';
            loadNodes();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function testNode(nodeId) {
    try {
        const response = await fetch(`/api/nodes/${nodeId}/test`, {method: 'POST'});
        const data = await response.json();
        showInfo(data.message);
    } catch (error) {
        showError(error.message);
    }
}

async function deleteNode(nodeId) {
    if (!confirm('Delete this node?')) return;

    try {
        const response = await fetch(`/api/nodes/${nodeId}`, {method: 'DELETE'});
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            loadNodes();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

// Load everything on page load
loadSettings();
loadModels();
loadNodes();
</script>
{% endblock %}
