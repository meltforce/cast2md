{% extends "base.html" %}

{% block title %}{{ feed.display_title }} - cast2md{% endblock %}

{% block content %}
<p><a href="/">&larr; Back to feeds</a></p>

<hgroup>
    <h1>
        {{ feed.display_title }}
        <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; vertical-align: middle; margin-left: 0.5rem;" onclick="document.getElementById('editTitleModal').showModal()">Edit</button>
    </h1>
    {% if feed.author %}<p style="margin-bottom: 0.25rem;">by {{ feed.author }}</p>{% endif %}
    {% set desc = feed.description|strip_html %}
    <p>{{ desc[:200] + '...' if desc and desc|length > 200 else desc or 'No description' }}</p>
</hgroup>

<p>
    {% if feed.link %}<a href="{{ feed.link }}" target="_blank">Website</a> | {% endif %}
    <strong>{{ total }}</strong> episodes
    &nbsp;|&nbsp;
    Last polled: {{ feed.last_polled.strftime('%Y-%m-%d %H:%M') if feed.last_polled else 'Never' }}
    &nbsp;|&nbsp;
    <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;" onclick="refreshFeed({{ feed.id }})">Refresh Feed</button>
    <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; display: none;" onclick="queueSelected()" id="queueSelectedBtn">Queue Selected (<span id="selectedCount">0</span>)</button>
</p>

<dialog id="editTitleModal">
    <article>
        <header>
            <button aria-label="Close" rel="prev" onclick="this.closest('dialog').close()"></button>
            <h3>Edit Feed Title</h3>
        </header>
        <form onsubmit="saveFeedTitle(event)">
            <label>
                Original RSS Title
                <input value="{{ feed.title }}" disabled>
            </label>
            <label>
                Custom Title (leave blank to use RSS title)
                <input type="text" id="customTitleInput" value="{{ feed.custom_title or '' }}" placeholder="{{ feed.title }}">
            </label>
            <footer style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                <button type="button" class="secondary" onclick="this.closest('dialog').close()">Cancel</button>
                <button type="submit">Save</button>
            </footer>
        </form>
    </article>
</dialog>

<article style="margin-bottom: 1rem; padding: 1rem; background: var(--card-background-color);">
    <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
        <strong>Batch Queue:</strong>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
            <label style="margin: 0; font-size: 0.875rem;">Position</label>
            <input type="number" id="posFrom" placeholder="From" min="1" style="width: 5rem; padding: 0.25rem 0.5rem; margin: 0;">
            <span>-</span>
            <input type="number" id="posTo" placeholder="To" min="1" style="width: 5rem; padding: 0.25rem 0.5rem; margin: 0;">
            <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;" onclick="queueByPosition({{ feed.id }})">Queue</button>
        </div>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
            <label style="margin: 0; font-size: 0.875rem;">Date</label>
            <input type="date" id="dateFrom" style="padding: 0.25rem 0.5rem; margin: 0;">
            <span>-</span>
            <input type="date" id="dateTo" style="padding: 0.25rem 0.5rem; margin: 0;">
            <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;" onclick="queueByDate({{ feed.id }})">Queue</button>
        </div>
        <button class="outline secondary" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;" onclick="queueAllPending({{ feed.id }})">Queue All Pending</button>
    </div>
</article>

<article style="margin-bottom: 1rem; padding: 1rem; background: var(--card-background-color);">
    <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
        <strong>Export Transcripts:</strong>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
            <select id="exportFormat" style="padding: 0.25rem 0.5rem; margin: 0; width: auto;">
                <option value="md">Markdown (.md)</option>
                <option value="txt">Plain Text (.txt)</option>
                <option value="srt">SRT Subtitles (.srt)</option>
                <option value="vtt">WebVTT (.vtt)</option>
                <option value="json">JSON (.json)</option>
            </select>
            <a id="exportLink" href="/api/feeds/{{ feed.id }}/export?format=md" role="button" class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;">Download All (ZIP)</a>
        </div>
    </div>
</article>

<table>
    <thead>
        <tr>
            <th style="width: 2rem;"><input type="checkbox" id="selectAll" onchange="toggleSelectAll()"></th>
            <th>Episode</th>
            <th style="white-space: nowrap;">Published</th>
            <th style="white-space: nowrap;">Status</th>
            <th style="white-space: nowrap;">Actions</th>
        </tr>
    </thead>
    <tbody>
        {% for episode in episodes %}
        <tr>
            <td>
                <input type="checkbox" class="episode-checkbox" value="{{ episode.id }}"
                       onchange="updateSelectedCount()" {% if episode.status.value != 'pending' %}disabled{% endif %}>
            </td>
            <td>
                <a href="/episodes/{{ episode.id }}" class="truncate" style="display: block;">
                    {{ episode.title }}
                </a>
            </td>
            <td style="white-space: nowrap;">{{ episode.published_at.strftime('%Y-%m-%d') if episode.published_at else 'Unknown' }}</td>
            <td style="white-space: nowrap;">
                <span class="status-badge status-{{ episode.status.value }}">{{ episode.status.value }}</span>
            </td>
            <td class="actions" style="white-space: nowrap;">
                {% if episode.status.value == 'pending' %}
                    <button class="outline" onclick="downloadEpisode({{ episode.id }})">Download</button>
                {% elif episode.status.value == 'downloaded' %}
                    <button class="outline" onclick="transcribeEpisode({{ episode.id }})">Transcribe</button>
                {% elif episode.status.value == 'completed' and episode.transcript_path %}
                    <a href="/episodes/{{ episode.id }}" class="outline" role="button">View</a>
                {% elif episode.status.value == 'failed' %}
                    <button class="outline secondary" onclick="retryEpisode({{ episode.id }})">Retry</button>
                {% endif %}
            </td>
        </tr>
        {% endfor %}
    </tbody>
</table>

{% if total_pages > 1 %}
<nav>
    <ul>
        {% if page > 1 %}
        <li><a href="?page={{ page - 1 }}">&larr; Previous</a></li>
        {% endif %}
    </ul>
    <ul>
        <li>Page {{ page }} of {{ total_pages }}</li>
    </ul>
    <ul>
        {% if page < total_pages %}
        <li><a href="?page={{ page + 1 }}">Next &rarr;</a></li>
        {% endif %}
    </ul>
</nav>
{% endif %}
{% endblock %}

{% block scripts %}
<script>
// Update export link when format changes
document.getElementById('exportFormat').addEventListener('change', function() {
    const format = this.value;
    document.getElementById('exportLink').href = `/api/feeds/{{ feed.id }}/export?format=${format}`;
});

async function saveFeedTitle(event) {
    event.preventDefault();
    const customTitle = document.getElementById('customTitleInput').value.trim();

    try {
        const response = await fetch(`/api/feeds/{{ feed.id }}`, {
            method: 'PATCH',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({custom_title: customTitle || null})
        });

        if (response.ok) {
            window.location.reload();
        } else {
            const data = await response.json();
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function refreshFeed(feedId) {
    try {
        const response = await fetch(`/api/feeds/${feedId}/refresh`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function downloadEpisode(episodeId) {
    try {
        const response = await fetch(`/api/episodes/${episodeId}/download`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function transcribeEpisode(episodeId) {
    if (!confirm('Start transcription? This may take several minutes.')) {
        return;
    }

    try {
        const response = await fetch(`/api/episodes/${episodeId}/transcribe`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function retryEpisode(episodeId) {
    // For now, just try download again
    await downloadEpisode(episodeId);
}

async function queueAllPending(feedId) {
    if (!confirm('Queue all pending episodes for processing?')) {
        return;
    }

    try {
        const response = await fetch(`/api/queue/batch/feed/${feedId}/process`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Selection management
function toggleSelectAll() {
    const selectAll = document.getElementById('selectAll');
    document.querySelectorAll('.episode-checkbox:not(:disabled)').forEach(cb => {
        cb.checked = selectAll.checked;
    });
    updateSelectedCount();
}

function updateSelectedCount() {
    const selected = document.querySelectorAll('.episode-checkbox:checked').length;
    document.getElementById('selectedCount').textContent = selected;
    document.getElementById('queueSelectedBtn').style.display = selected > 0 ? 'inline-block' : 'none';
}

async function queueSelected() {
    const selected = Array.from(document.querySelectorAll('.episode-checkbox:checked'))
        .map(cb => parseInt(cb.value));

    if (selected.length === 0) {
        alert('No episodes selected');
        return;
    }

    if (!confirm(`Queue ${selected.length} selected episode(s) for processing?`)) {
        return;
    }

    try {
        const response = await fetch('/api/queue/batch/episodes', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({episode_ids: selected})
        });
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function queueByPosition(feedId) {
    const posFrom = document.getElementById('posFrom').value;
    const posTo = document.getElementById('posTo').value;

    if (!posFrom && !posTo) {
        alert('Please specify at least one position value');
        return;
    }

    const rangeDesc = posFrom && posTo ? `episodes ${posFrom}-${posTo}` :
                      posFrom ? `episodes from position ${posFrom}` :
                      `episodes up to position ${posTo}`;

    if (!confirm(`Queue ${rangeDesc} for processing?`)) {
        return;
    }

    try {
        const response = await fetch('/api/queue/batch/range', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                feed_id: feedId,
                position_from: posFrom ? parseInt(posFrom) : null,
                position_to: posTo ? parseInt(posTo) : null
            })
        });
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function queueByDate(feedId) {
    const dateFrom = document.getElementById('dateFrom').value;
    const dateTo = document.getElementById('dateTo').value;

    if (!dateFrom && !dateTo) {
        alert('Please specify at least one date');
        return;
    }

    const rangeDesc = dateFrom && dateTo ? `episodes from ${dateFrom} to ${dateTo}` :
                      dateFrom ? `episodes from ${dateFrom}` :
                      `episodes up to ${dateTo}`;

    if (!confirm(`Queue ${rangeDesc} for processing?`)) {
        return;
    }

    try {
        const response = await fetch('/api/queue/batch/range', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                feed_id: feedId,
                date_from: dateFrom || null,
                date_to: dateTo || null
            })
        });
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}
</script>
{% endblock %}
