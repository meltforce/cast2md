{% extends "base.html" %}

{% block title %}{{ feed.display_title }} - cast2md{% endblock %}

{% block content %}
<p><a href="/">&larr; Back to feeds</a></p>

<hgroup>
    <h1>
        {{ feed.display_title }}
        <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; vertical-align: middle; margin-left: 0.5rem;" onclick="document.getElementById('editTitleModal').showModal()">Edit</button>
    </h1>
    {% if feed.author %}<p style="margin-bottom: 0.25rem;">by {{ feed.author }}</p>{% endif %}
    {% set desc = feed.description|strip_html %}
    <p>{{ desc[:200] + '...' if desc and desc|length > 200 else desc or 'No description' }}</p>
</hgroup>

<p>
    {% if feed.link %}<a href="{{ feed.link }}" target="_blank">Website</a> | {% endif %}
    <strong>{{ total_all }}</strong> episodes
    &nbsp;|&nbsp;
    Last polled: {{ feed.last_polled.strftime('%Y-%m-%d %H:%M') if feed.last_polled else 'Never' }}
    &nbsp;|&nbsp;
    <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;" onclick="refreshFeed({{ feed.id }})">Refresh Feed</button>
    <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; display: none;" onclick="queueSelected()" id="queueSelectedBtn">Queue Selected (<span id="selectedCount">0</span>)</button>
</p>

<dialog id="editTitleModal">
    <article>
        <header>
            <button aria-label="Close" rel="prev" onclick="this.closest('dialog').close()"></button>
            <h3>Edit Feed Title</h3>
        </header>
        <form onsubmit="saveFeedTitle(event)">
            <label>
                Original RSS Title
                <input value="{{ feed.title }}" disabled>
            </label>
            <label>
                Custom Title (leave blank to use RSS title)
                <input type="text" id="customTitleInput" value="{{ feed.custom_title or '' }}" placeholder="{{ feed.title }}">
            </label>
            <footer style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                <button type="button" class="secondary" onclick="this.closest('dialog').close()">Cancel</button>
                <button type="submit">Save</button>
            </footer>
        </form>
    </article>
</dialog>

<article style="margin-bottom: 1rem; padding: 1rem; background: var(--card-background-color);">
    <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
        <strong>Batch Queue:</strong>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
            <label style="margin: 0; font-size: 0.875rem;">Position</label>
            <input type="number" id="posFrom" placeholder="From" min="1" style="width: 5rem; padding: 0.25rem 0.5rem; margin: 0;">
            <span>-</span>
            <input type="number" id="posTo" placeholder="To" min="1" style="width: 5rem; padding: 0.25rem 0.5rem; margin: 0;">
            <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;" onclick="queueByPosition({{ feed.id }})">Queue</button>
        </div>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
            <label style="margin: 0; font-size: 0.875rem;">Date</label>
            <input type="date" id="dateFrom" style="padding: 0.25rem 0.5rem; margin: 0;">
            <span>-</span>
            <input type="date" id="dateTo" style="padding: 0.25rem 0.5rem; margin: 0;">
            <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;" onclick="queueByDate({{ feed.id }})">Queue</button>
        </div>
        <button class="outline secondary" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;" onclick="queueAllPending({{ feed.id }})">Queue All Pending</button>
    </div>
</article>

<article style="margin-bottom: 1rem; padding: 1rem; background: var(--card-background-color);">
    <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
        <strong>Export Transcripts:</strong>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
            <select id="exportFormat" style="padding: 0.25rem 0.5rem; margin: 0; width: auto;">
                <option value="md">Markdown (.md)</option>
                <option value="txt">Plain Text (.txt)</option>
                <option value="srt">SRT Subtitles (.srt)</option>
                <option value="vtt">WebVTT (.vtt)</option>
                <option value="json">JSON (.json)</option>
            </select>
            <a id="exportLink" href="/api/feeds/{{ feed.id }}/export?format=md" role="button" class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;">Download All (ZIP)</a>
        </div>
    </div>
</article>

<article id="retranscribeSection" style="margin-bottom: 1rem; padding: 1rem; background: var(--card-background-color); display: none;">
    <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
        <strong>Re-transcription:</strong>
        <span id="retranscribeInfo" style="color: var(--muted-color);"></span>
        <button id="retranscribeBtn" class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;" onclick="batchRetranscribe({{ feed.id }})">
            Re-transcribe All Outdated
        </button>
    </div>
</article>

<!-- Search and Filter Section -->
<article style="margin-bottom: 1rem; padding: 1rem; background: var(--card-background-color);">
    <form id="searchForm" method="get" style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
        <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1; min-width: 200px;">
            <input type="text" name="q" id="searchInput" placeholder="Search episodes..."
                   value="{{ query }}" style="margin: 0; padding: 0.5rem;">
        </div>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
            <label style="margin: 0; font-size: 0.875rem;">Status:</label>
            <select name="status" id="statusFilter" style="padding: 0.25rem 0.5rem; margin: 0; width: auto;">
                <option value="">All</option>
                {% for s in statuses %}
                <option value="{{ s }}" {% if status_filter == s %}selected{% endif %}>{{ s|capitalize }}</option>
                {% endfor %}
            </select>
        </div>
        <input type="hidden" name="per_page" value="{{ per_page }}">
        <button type="submit" style="padding: 0.5rem 1rem; margin: 0;">Search</button>
        {% if query or status_filter %}
        <a href="?per_page={{ per_page }}" role="button" class="outline secondary" style="padding: 0.5rem 1rem; margin: 0;">Clear Filters</a>
        {% endif %}
    </form>
    {% if query or status_filter %}
    <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem;">
        Showing <strong>{{ total }}</strong> results
        {% if query %} for "<strong>{{ query }}</strong>"{% endif %}
        {% if status_filter %} with status <strong>{{ status_filter }}</strong>{% endif %}
        ({{ total_all }} total episodes)
    </p>
    {% endif %}
</article>

<table>
    <thead>
        <tr>
            <th style="width: 2rem;"><input type="checkbox" id="selectAll" onchange="toggleSelectAll()"></th>
            <th>Episode</th>
            <th style="white-space: nowrap;">Published</th>
            <th style="white-space: nowrap;">Status</th>
            <th style="white-space: nowrap;">Actions</th>
        </tr>
    </thead>
    <tbody>
        {% for episode in episodes %}
        <tr>
            <td>
                <input type="checkbox" class="episode-checkbox" value="{{ episode.id }}"
                       onchange="updateSelectedCount()" {% if episode.status.value != 'pending' %}disabled{% endif %}>
            </td>
            <td>
                {% set ep_params = [] %}
                {% if query %}{% set _ = ep_params.append('q=' ~ query|urlencode) %}{% endif %}
                {% if status_filter %}{% set _ = ep_params.append('status=' ~ status_filter) %}{% endif %}
                {% if per_page != 25 %}{% set _ = ep_params.append('per_page=' ~ per_page) %}{% endif %}
                {% if page != 1 %}{% set _ = ep_params.append('page=' ~ page) %}{% endif %}
                <a href="/episodes/{{ episode.id }}{% if ep_params %}?{{ ep_params|join('&') }}{% endif %}" class="truncate" style="display: block;">
                    {{ episode.title }}
                </a>
            </td>
            <td style="white-space: nowrap;">{{ episode.published_at.strftime('%Y-%m-%d') if episode.published_at else 'Unknown' }}</td>
            <td style="white-space: nowrap;">
                <span class="status-badge status-{{ episode.status.value }}">{{ episode.status.value }}</span>
            </td>
            <td class="actions" style="white-space: nowrap;">
                {% if episode.status.value == 'pending' %}
                    <button class="outline" onclick="tryTranscript({{ episode.id }})">Get Transcript</button>
                {% elif episode.status.value == 'downloaded' %}
                    <button class="outline" onclick="transcribeEpisode({{ episode.id }})">Transcribe</button>
                {% elif episode.status.value == 'completed' and episode.transcript_path %}
                    <a href="/episodes/{{ episode.id }}" class="outline" role="button">View</a>
                {% elif episode.status.value == 'failed' %}
                    <button class="outline secondary" onclick="retryEpisode({{ episode.id }})">Retry</button>
                {% endif %}
            </td>
        </tr>
        {% else %}
        <tr>
            <td colspan="5" style="text-align: center; padding: 2rem;">
                {% if query or status_filter %}
                No episodes found matching your search criteria.
                {% else %}
                No episodes in this feed.
                {% endif %}
            </td>
        </tr>
        {% endfor %}
    </tbody>
</table>

<!-- Pagination Section -->
{% if total_pages > 0 %}
<nav style="display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; gap: 1rem; margin-top: 1rem;">
    <!-- Items per page selector -->
    <div style="display: flex; align-items: center; gap: 0.5rem;">
        <label style="margin: 0; font-size: 0.875rem;">Items per page:</label>
        <select id="perPageSelect" style="padding: 0.25rem 0.5rem; margin: 0; width: auto;">
            {% for pp in valid_per_page %}
            <option value="{{ pp }}" {% if per_page == pp %}selected{% endif %}>{{ pp }}</option>
            {% endfor %}
        </select>
    </div>

    <!-- Page navigation -->
    {% if total_pages > 1 %}
    {# Build base URL with current query/status/per_page params #}
    {% set base_params = [] %}
    {% if query %}{% set _ = base_params.append('q=' ~ query|urlencode) %}{% endif %}
    {% if status_filter %}{% set _ = base_params.append('status=' ~ status_filter) %}{% endif %}
    {% set _ = base_params.append('per_page=' ~ per_page) %}
    {% set base_url = '?' ~ base_params|join('&') ~ '&page=' %}

    <div style="display: flex; align-items: center; gap: 0.25rem; flex-wrap: wrap;">
        {# First and Previous buttons #}
        {% if page > 1 %}
        <a href="{{ base_url }}1" role="button" class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" title="First page">First</a>
        <a href="{{ base_url }}{{ page - 1 }}" role="button" class="outline" style="padding: 0.25rem 0.5rem; margin: 0;">&larr; Prev</a>
        {% else %}
        <button class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" disabled>First</button>
        <button class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" disabled>&larr; Prev</button>
        {% endif %}

        {# Page numbers with ellipsis #}
        {% set show_pages = [] %}
        {% for p in range(1, total_pages + 1) %}
            {% if p <= 3 or p > total_pages - 3 or (p >= page - 1 and p <= page + 1) %}
                {% set _ = show_pages.append(p) %}
            {% endif %}
        {% endfor %}

        {% set prev_page = namespace(value=0) %}
        {% for p in show_pages %}
            {% if p > prev_page.value + 1 %}
            <span style="padding: 0.25rem;">...</span>
            {% endif %}
            {% if p == page %}
            <button style="padding: 0.25rem 0.5rem; margin: 0; font-weight: bold;">{{ p }}</button>
            {% else %}
            <a href="{{ base_url }}{{ p }}" role="button" class="outline" style="padding: 0.25rem 0.5rem; margin: 0;">{{ p }}</a>
            {% endif %}
            {% set prev_page.value = p %}
        {% endfor %}

        {# Next and Last buttons #}
        {% if page < total_pages %}
        <a href="{{ base_url }}{{ page + 1 }}" role="button" class="outline" style="padding: 0.25rem 0.5rem; margin: 0;">Next &rarr;</a>
        <a href="{{ base_url }}{{ total_pages }}" role="button" class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" title="Last page">Last</a>
        {% else %}
        <button class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" disabled>Next &rarr;</button>
        <button class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" disabled>Last</button>
        {% endif %}
    </div>

    <!-- Go to page input -->
    <div style="display: flex; align-items: center; gap: 0.5rem;">
        <label style="margin: 0; font-size: 0.875rem;">Page:</label>
        <input type="number" id="gotoPageInput" min="1" max="{{ total_pages }}" value="{{ page }}"
               style="width: 4rem; padding: 0.25rem 0.5rem; margin: 0;">
        <span style="font-size: 0.875rem;">of {{ total_pages }}</span>
        <button class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" onclick="gotoPage()">Go</button>
    </div>
    {% endif %}
</nav>
{% endif %}
{% endblock %}

{% block scripts %}
<script>
// Build URL with current query params
function buildPageUrl(pageNum) {
    const params = new URLSearchParams(window.location.search);
    params.set('page', pageNum);
    return '?' + params.toString();
}

// Initialize: Apply stored per_page preference and load retranscribe info
document.addEventListener('DOMContentLoaded', function() {
    const storedPerPage = localStorage.getItem('cast2md_per_page');
    const currentPerPage = {{ per_page }};
    const params = new URLSearchParams(window.location.search);

    // If there's a stored preference and it's not already applied via URL
    if (storedPerPage && !params.has('per_page') && parseInt(storedPerPage) !== currentPerPage) {
        params.set('per_page', storedPerPage);
        params.delete('page'); // Reset to page 1 when changing per_page
        window.location.search = params.toString();
    }

    // Load retranscription info
    loadRetranscribeInfo({{ feed.id }});
});

async function loadRetranscribeInfo(feedId) {
    try {
        const response = await fetch(`/api/queue/retranscribe/info/${feedId}`);
        const data = await response.json();

        if (response.ok && data.needs_retranscription > 0) {
            document.getElementById('retranscribeSection').style.display = 'block';
            document.getElementById('retranscribeInfo').textContent =
                `${data.needs_retranscription} episode(s) can be updated to "${data.current_model}"`;
        }
    } catch (error) {
        console.error('Failed to load retranscribe info:', error);
    }
}

async function batchRetranscribe(feedId) {
    const infoText = document.getElementById('retranscribeInfo').textContent;
    if (!confirm(`Re-transcribe all outdated episodes?\n\n${infoText}\n\nThis will replace existing transcripts.`)) {
        return;
    }

    try {
        const response = await fetch(`/api/queue/batch/feed/${feedId}/retranscribe`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Update export link when format changes
document.getElementById('exportFormat').addEventListener('change', function() {
    const format = this.value;
    document.getElementById('exportLink').href = `/api/feeds/{{ feed.id }}/export?format=${format}`;
});

// Per-page selector change
document.getElementById('perPageSelect').addEventListener('change', function() {
    const perPage = this.value;
    localStorage.setItem('cast2md_per_page', perPage);

    const params = new URLSearchParams(window.location.search);
    params.set('per_page', perPage);
    params.delete('page'); // Reset to page 1 when changing per_page
    window.location.search = params.toString();
});

// Go to specific page
function gotoPage() {
    const input = document.getElementById('gotoPageInput');
    const pageNum = parseInt(input.value);
    const totalPages = {{ total_pages }};

    if (pageNum >= 1 && pageNum <= totalPages) {
        window.location.href = buildPageUrl(pageNum);
    } else {
        alert(`Please enter a page number between 1 and ${totalPages}`);
    }
}

// Handle Enter key on goto page input
document.getElementById('gotoPageInput')?.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        gotoPage();
    }
});

async function saveFeedTitle(event) {
    event.preventDefault();
    const customTitle = document.getElementById('customTitleInput').value.trim();

    try {
        const response = await fetch(`/api/feeds/{{ feed.id }}`, {
            method: 'PATCH',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({custom_title: customTitle || null})
        });

        if (response.ok) {
            window.location.reload();
        } else {
            const data = await response.json();
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function refreshFeed(feedId) {
    try {
        const response = await fetch(`/api/feeds/${feedId}/refresh`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function tryTranscript(episodeId) {
    try {
        // Try to get transcript from external providers first
        const response = await fetch(`/api/queue/episodes/${episodeId}/transcript-download`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message + '\n\nIf no external transcript is available, you can use "Download Audio" from the episode detail page.');
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function downloadEpisode(episodeId) {
    try {
        // Use queue endpoint instead of synchronous download
        const response = await fetch(`/api/queue/episodes/${episodeId}/process`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function transcribeEpisode(episodeId) {
    try {
        // Use queue endpoint instead of synchronous transcription
        const response = await fetch(`/api/queue/episodes/${episodeId}/transcribe`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function retryEpisode(episodeId) {
    // For now, just try download again
    await downloadEpisode(episodeId);
}

async function queueAllPending(feedId) {
    if (!confirm('Queue all pending episodes for processing?')) {
        return;
    }

    try {
        const response = await fetch(`/api/queue/batch/feed/${feedId}/process`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Selection management
function toggleSelectAll() {
    const selectAll = document.getElementById('selectAll');
    document.querySelectorAll('.episode-checkbox:not(:disabled)').forEach(cb => {
        cb.checked = selectAll.checked;
    });
    updateSelectedCount();
}

function updateSelectedCount() {
    const selected = document.querySelectorAll('.episode-checkbox:checked').length;
    document.getElementById('selectedCount').textContent = selected;
    document.getElementById('queueSelectedBtn').style.display = selected > 0 ? 'inline-block' : 'none';
}

async function queueSelected() {
    const selected = Array.from(document.querySelectorAll('.episode-checkbox:checked'))
        .map(cb => parseInt(cb.value));

    if (selected.length === 0) {
        alert('No episodes selected');
        return;
    }

    if (!confirm(`Queue ${selected.length} selected episode(s) for processing?`)) {
        return;
    }

    try {
        const response = await fetch('/api/queue/batch/episodes', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({episode_ids: selected})
        });
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function queueByPosition(feedId) {
    const posFrom = document.getElementById('posFrom').value;
    const posTo = document.getElementById('posTo').value;

    if (!posFrom && !posTo) {
        alert('Please specify at least one position value');
        return;
    }

    const rangeDesc = posFrom && posTo ? `episodes ${posFrom}-${posTo}` :
                      posFrom ? `episodes from position ${posFrom}` :
                      `episodes up to position ${posTo}`;

    if (!confirm(`Queue ${rangeDesc} for processing?`)) {
        return;
    }

    try {
        const response = await fetch('/api/queue/batch/range', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                feed_id: feedId,
                position_from: posFrom ? parseInt(posFrom) : null,
                position_to: posTo ? parseInt(posTo) : null
            })
        });
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function queueByDate(feedId) {
    const dateFrom = document.getElementById('dateFrom').value;
    const dateTo = document.getElementById('dateTo').value;

    if (!dateFrom && !dateTo) {
        alert('Please specify at least one date');
        return;
    }

    const rangeDesc = dateFrom && dateTo ? `episodes from ${dateFrom} to ${dateTo}` :
                      dateFrom ? `episodes from ${dateFrom}` :
                      `episodes up to ${dateTo}`;

    if (!confirm(`Queue ${rangeDesc} for processing?`)) {
        return;
    }

    try {
        const response = await fetch('/api/queue/batch/range', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                feed_id: feedId,
                date_from: dateFrom || null,
                date_to: dateTo || null
            })
        });
        const data = await response.json();

        if (response.ok) {
            alert(data.message);
            window.location.reload();
        } else {
            alert('Error: ' + data.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}
</script>
{% endblock %}
