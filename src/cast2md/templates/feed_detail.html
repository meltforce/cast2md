{% extends "base.html" %}

{% block title %}{{ feed.display_title }} - cast2md{% endblock %}

{% block content %}
<p><a href="/feeds">&larr; Back to feeds</a></p>

<div style="display: flex; gap: 1.5rem; align-items: flex-start; margin-bottom: 1rem;">
    {% if feed.image_url %}
    <img src="{{ feed.image_url }}" alt="{{ feed.display_title }}" style="width: 150px; height: 150px; object-fit: cover; border-radius: 8px; flex-shrink: 0;">
    {% endif %}
    <hgroup style="margin: 0;">
        <h1 style="margin-bottom: 0.25rem;">
            {{ feed.display_title }}
            <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; vertical-align: middle; margin-left: 0.5rem;" onclick="document.getElementById('editTitleModal').showModal()">Edit</button>
        </h1>
        {% if feed.author %}<p style="margin-bottom: 0.25rem;">by {{ feed.author }}</p>{% endif %}
        {% if feed.category_list %}<p style="margin-bottom: 0.25rem; color: var(--muted-color); font-size: 0.875rem;">{{ feed.category_list|join(', ') }}</p>{% endif %}
        {% set desc = feed.description|strip_html %}
        <p style="margin-bottom: 0;">{{ desc[:200] + '...' if desc and desc|length > 200 else desc or 'No description' }}</p>
    </hgroup>
</div>

<p>
    {% if feed.link %}<a href="{{ feed.link }}" target="_blank">Website</a> | {% endif %}
    <strong>{{ total_all }}</strong> episodes
    &nbsp;|&nbsp;
    Last polled: {{ feed.last_polled.strftime('%Y-%m-%d %H:%M') if feed.last_polled else 'Never' }}
    &nbsp;|&nbsp;
    <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;" onclick="refreshFeed({{ feed.id }})">Refresh Feed</button>
    <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; display: none;" onclick="queueSelected()" id="queueSelectedBtn">Queue Selected (<span id="selectedCount">0</span>)</button>
    <button class="outline secondary" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;" onclick="document.getElementById('deleteFeedDialog').showModal()">Delete Feed</button>
</p>

<!-- Transcript source info -->
<p style="font-size: 0.875rem; color: var(--muted-color);">
    <strong>Transcripts:</strong>
    {% if transcript_stats.podcast20 > 0 %}
        <span class="match-keyword" style="padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.75rem;">Podcast 2.0</span> {{ transcript_stats.podcast20 }}
    {% endif %}
    {% if transcript_stats.pocketcasts > 0 %}
        <span class="match-semantic" style="padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.75rem;">Pocket Casts</span> {{ transcript_stats.pocketcasts }}
    {% endif %}
    {% if transcript_stats.whisper_only > 0 %}
        <span class="match-whisper" style="padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.75rem;">Whisper</span> {{ transcript_stats.whisper_only }}
    {% endif %}
    {% if transcript_stats.podcast20 == 0 and transcript_stats.pocketcasts == 0 %}
        No external transcripts available (Whisper required for all episodes)
    {% endif %}
</p>

<dialog id="deleteFeedDialog">
    <article>
        <header>
            <button aria-label="Close" rel="prev" onclick="this.closest('dialog').close()"></button>
            <h3>Delete Feed</h3>
        </header>
        <p>Are you sure you want to delete <strong>{{ feed.display_title }}</strong>?</p>
        <p>This will remove all {{ total_all }} episodes from the database. Files will be moved to trash and automatically deleted after 30 days.</p>
        <label>
            Type <strong>delete</strong> to confirm
            <input type="text" id="deleteConfirmInput" placeholder="delete" autocomplete="off">
        </label>
        <footer style="display: flex; gap: 0.5rem; justify-content: flex-end;">
            <button type="button" class="secondary" onclick="this.closest('dialog').close()">Cancel</button>
            <button type="button" class="contrast" id="deleteConfirmBtn" onclick="confirmDeleteFeed()" disabled>Delete Feed</button>
        </footer>
    </article>
</dialog>

<dialog id="editTitleModal">
    <article>
        <header>
            <button aria-label="Close" rel="prev" onclick="this.closest('dialog').close()"></button>
            <h3>Edit Feed Title</h3>
        </header>
        <form onsubmit="saveFeedTitle(event)">
            <label>
                Original RSS Title
                <input value="{{ feed.title }}" disabled>
            </label>
            <label>
                Custom Title (leave blank to use RSS title)
                <input type="text" id="customTitleInput" value="{{ feed.custom_title or '' }}" placeholder="{{ feed.title }}">
            </label>
            <footer style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                <button type="button" class="secondary" onclick="this.closest('dialog').close()">Cancel</button>
                <button type="submit">Save</button>
            </footer>
        </form>
    </article>
</dialog>

<details style="margin-bottom: 1rem;">
    <summary style="cursor: pointer; padding: 0.75rem 1rem; background: var(--card-background-color); border-radius: var(--border-radius); font-weight: 600;">
        Actions (Batch Queue, Export, Re-transcribe)
    </summary>
    <div style="padding: 1rem; background: var(--card-background-color); border-top: 1px solid var(--muted-border-color);">
        <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem;">
            <strong style="min-width: 100px;">Batch Queue:</strong>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <label style="margin: 0; font-size: 0.875rem;">Position</label>
                <input type="number" id="posFrom" placeholder="From" min="1" style="width: 5rem; padding: 0.25rem 0.5rem; margin: 0;">
                <span>-</span>
                <input type="number" id="posTo" placeholder="To" min="1" style="width: 5rem; padding: 0.25rem 0.5rem; margin: 0;">
                <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;" onclick="queueByPosition({{ feed.id }})">Queue</button>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <label style="margin: 0; font-size: 0.875rem;">Date</label>
                <input type="date" id="dateFrom" style="padding: 0.25rem 0.5rem; margin: 0;">
                <span>-</span>
                <input type="date" id="dateTo" style="padding: 0.25rem 0.5rem; margin: 0;">
                <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;" onclick="queueByDate({{ feed.id }})">Queue</button>
            </div>
            {% if needs_transcription_count > 0 %}
            <button class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;" onclick="queueAllDownloads({{ feed.id }})">Download & Transcribe All ({{ needs_transcription_count }})</button>
            {% endif %}
        </div>

        <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem;">
            <strong style="min-width: 100px;">Export:</strong>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <select id="exportFormat" style="padding: 0.25rem 0.5rem; margin: 0; width: auto;">
                    <option value="md">Markdown (.md)</option>
                    <option value="txt">Plain Text (.txt)</option>
                    <option value="srt">SRT Subtitles (.srt)</option>
                    <option value="vtt">WebVTT (.vtt)</option>
                    <option value="json">JSON (.json)</option>
                </select>
                <a id="exportLink" href="/api/feeds/{{ feed.id }}/export?format=md" role="button" class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;">Download All (ZIP)</a>
            </div>
        </div>

        <div id="retranscribeSection" style="display: none; align-items: center; gap: 1rem; flex-wrap: wrap;">
            <strong style="min-width: 100px;">Re-transcribe:</strong>
            <span id="retranscribeInfo" style="color: var(--muted-color);"></span>
            <button id="retranscribeBtn" class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin: 0;" onclick="batchRetranscribe({{ feed.id }})">
                Re-transcribe All Outdated
            </button>
        </div>
    </div>
</details>

<!-- Search and Filter Section -->
<article style="margin-bottom: 1rem; padding: 1rem; background: var(--card-background-color);">
    <form id="searchForm" method="get" style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
        <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1; min-width: 200px;">
            <input type="text" name="q" id="searchInput" placeholder="Search episodes..."
                   value="{{ query }}" style="margin: 0; padding: 0.5rem;">
        </div>
        <div style="display: flex; align-items: center; gap: 0.5rem;">
            <label style="margin: 0; font-size: 0.875rem;">Status:</label>
            {% set status_labels = {
                'new': 'New',
                'awaiting_transcript': 'Awaiting Transcript',
                'needs_audio': 'Needs Audio',
                'downloading': 'Downloading',
                'audio_ready': 'Audio Ready',
                'transcribing': 'Transcribing',
                'completed': 'Completed',
                'failed': 'Failed'
            } %}
            <select name="status" id="statusFilter" style="padding: 0.25rem 0.5rem; margin: 0; width: auto;">
                <option value="">All</option>
                {% for s in statuses %}
                <option value="{{ s }}" {% if status_filter == s %}selected{% endif %}>{{ status_labels.get(s, s|capitalize) }}</option>
                {% endfor %}
            </select>
        </div>
        <input type="hidden" name="per_page" value="{{ per_page }}">
        <button type="submit" style="padding: 0.5rem 1rem; margin: 0;">Search</button>
        {% if query or status_filter %}
        <a href="?per_page={{ per_page }}" role="button" class="outline secondary" style="padding: 0.5rem 1rem; margin: 0;">Clear Filters</a>
        {% endif %}
    </form>
    {% if query or status_filter %}
    <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem;">
        Showing <strong>{{ total }}</strong> results
        {% if query %} for "<strong>{{ query }}</strong>"{% endif %}
        {% if status_filter %} with status <strong>{{ status_filter }}</strong>{% endif %}
        ({{ total_all }} total episodes)
    </p>
    {% endif %}
</article>

<table>
    <thead>
        <tr>
            <th style="width: 2rem;"><input type="checkbox" id="selectAll" onchange="toggleSelectAll()"></th>
            <th>Episode</th>
            <th style="white-space: nowrap;">Published</th>
            <th style="white-space: nowrap;">Duration</th>
            <th style="white-space: nowrap;">Progress</th>
            <th style="white-space: nowrap;">Actions</th>
        </tr>
    </thead>
    <tbody>
        {% for episode in episodes %}
        <tr id="episode-row-{{ episode.id }}"
            data-episode-id="{{ episode.id }}"
            data-has-external-transcript="{{ 'true' if (episode.transcript_url or episode.pocketcasts_transcript_url) else 'false' }}"
            data-is-queued="{{ 'true' if episode.id in queued_episode_ids else 'false' }}">
            <td>
                <input type="checkbox" class="episode-checkbox" value="{{ episode.id }}"
                       onchange="updateSelectedCount()" {% if episode.status.value != 'new' or episode.id in queued_episode_ids %}disabled{% endif %}>
            </td>
            <td>
                {% set ep_params = [] %}
                {% if query %}{% set _ = ep_params.append('q=' ~ query|urlencode) %}{% endif %}
                {% if status_filter %}{% set _ = ep_params.append('status=' ~ status_filter) %}{% endif %}
                {% if per_page != 25 %}{% set _ = ep_params.append('per_page=' ~ per_page) %}{% endif %}
                {% if page != 1 %}{% set _ = ep_params.append('page=' ~ page) %}{% endif %}
                <a href="/episodes/{{ episode.id }}{% if ep_params %}?{{ ep_params|join('&') }}{% endif %}" class="truncate" style="display: block;">
                    {{ episode.title }}
                </a>
            </td>
            <td style="white-space: nowrap;">{{ episode.published_at.strftime('%Y-%m-%d') if episode.published_at else 'Unknown' }}</td>
            <td style="white-space: nowrap; color: var(--muted-color);">{% if episode.duration_seconds %}{{ '%d:%02d' % (episode.duration_seconds // 60, episode.duration_seconds % 60) }}{% endif %}</td>
            <td style="white-space: nowrap;">
                {% set status = 'queued' if (episode.id in queued_episode_ids and episode.status.value == 'new') else episode.status.value %}
                {% set tooltips = {
                    'new': 'Ready to process',
                    'queued': 'Job queued, waiting to start',
                    'awaiting_transcript': 'Checking for external transcript, will retry',
                    'needs_audio': 'No external transcript - audio download required',
                    'downloading': 'Downloading audio...',
                    'audio_ready': 'Audio ready, waiting for transcription',
                    'transcribing': 'Transcribing with Whisper...',
                    'completed': 'Transcript available',
                    'failed': 'Processing failed'
                } %}
                <span class="progress-dots" data-status="{{ status }}" title="{{ tooltips.get(status, status) }}">
                    {% if status == 'new' %}
                    <span class="dot dot-empty">○</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>
                    {% elif status == 'queued' %}
                    <span class="dot dot-half">◐</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>
                    {% elif status == 'awaiting_transcript' %}
                    <span class="dot dot-half">◐</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>
                    {% elif status == 'needs_audio' %}
                    <span class="dot dot-done">●</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>
                    {% elif status == 'downloading' %}
                    <span class="dot dot-done">●</span><span class="dot dot-half">◐</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>
                    {% elif status == 'audio_ready' %}
                    <span class="dot dot-done">●</span><span class="dot dot-done">●</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>
                    {% elif status == 'transcribing' %}
                    <span class="dot dot-done">●</span><span class="dot dot-done">●</span><span class="dot dot-half">◐</span><span class="dot dot-empty">○</span>
                    {% elif status == 'completed' %}
                    <span class="dot dot-done">●</span><span class="dot dot-done">●</span><span class="dot dot-done">●</span><span class="dot dot-done">●</span>
                    {% elif status == 'failed' %}
                    <span class="dot dot-done">●</span><span class="dot dot-fail">✗</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>
                    {% endif %}
                </span>
            </td>
            <td class="actions" style="white-space: nowrap;">
                {% if episode.id in queued_episode_ids %}
                    <span class="actions-spacer"></span>
                {% elif episode.status.value == 'new' %}
                    {# NEW episodes auto-process, but show Download Audio as fallback #}
                    <button class="outline secondary" onclick="downloadEpisode({{ episode.id }})">Download Audio</button>
                {% elif episode.status.value == 'awaiting_transcript' %}
                    <button class="outline secondary" onclick="downloadEpisode({{ episode.id }})" title="Transcript not ready yet - download audio for Whisper instead">Download Audio</button>
                {% elif episode.status.value == 'needs_audio' %}
                    <button class="outline secondary" onclick="downloadEpisode({{ episode.id }})" title="No external transcript available - use Whisper">Download Audio</button>
                {% elif episode.status.value == 'downloading' or episode.status.value == 'transcribing' %}
                    <span class="actions-spacer"></span>
                {% elif episode.status.value == 'audio_ready' %}
                    <button class="outline secondary" onclick="transcribeEpisode({{ episode.id }}, this)">Transcribe</button>
                {% elif episode.status.value == 'completed' and episode.transcript_path %}
                    <a href="/episodes/{{ episode.id }}" class="outline secondary" role="button">View</a>
                {% elif episode.status.value == 'failed' %}
                    <button class="outline secondary" onclick="retryEpisode({{ episode.id }})">Retry</button>
                {% else %}
                    <span class="actions-spacer"></span>
                {% endif %}
            </td>
        </tr>
        {% else %}
        <tr>
            <td colspan="6" style="text-align: center; padding: 2rem;">
                {% if query or status_filter %}
                No episodes found matching your search criteria.
                {% else %}
                No episodes in this feed.
                {% endif %}
            </td>
        </tr>
        {% endfor %}
    </tbody>
</table>

<!-- Pagination Section -->
{% if total_pages > 0 %}
<nav style="display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; gap: 1rem; margin-top: 1rem;">
    <!-- Items per page selector -->
    <div style="display: flex; align-items: center; gap: 0.5rem;">
        <label style="margin: 0; font-size: 0.875rem;">Items per page:</label>
        <select id="perPageSelect" style="padding: 0.25rem 0.5rem; margin: 0; width: auto;">
            {% for pp in valid_per_page %}
            <option value="{{ pp }}" {% if per_page == pp %}selected{% endif %}>{{ pp }}</option>
            {% endfor %}
        </select>
    </div>

    <!-- Page navigation -->
    {% if total_pages > 1 %}
    {# Build base URL with current query/status/per_page params #}
    {% set base_params = [] %}
    {% if query %}{% set _ = base_params.append('q=' ~ query|urlencode) %}{% endif %}
    {% if status_filter %}{% set _ = base_params.append('status=' ~ status_filter) %}{% endif %}
    {% set _ = base_params.append('per_page=' ~ per_page) %}
    {% set base_url = '?' ~ base_params|join('&') ~ '&page=' %}

    <div style="display: flex; align-items: center; gap: 0.25rem; flex-wrap: wrap;">
        {# First and Previous buttons #}
        {% if page > 1 %}
        <a href="{{ base_url }}1" role="button" class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" title="First page">First</a>
        <a href="{{ base_url }}{{ page - 1 }}" role="button" class="outline" style="padding: 0.25rem 0.5rem; margin: 0;">&larr; Prev</a>
        {% else %}
        <button class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" disabled>First</button>
        <button class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" disabled>&larr; Prev</button>
        {% endif %}

        {# Page numbers with ellipsis #}
        {% set show_pages = [] %}
        {% for p in range(1, total_pages + 1) %}
            {% if p <= 3 or p > total_pages - 3 or (p >= page - 1 and p <= page + 1) %}
                {% set _ = show_pages.append(p) %}
            {% endif %}
        {% endfor %}

        {% set prev_page = namespace(value=0) %}
        {% for p in show_pages %}
            {% if p > prev_page.value + 1 %}
            <span style="padding: 0.25rem;">...</span>
            {% endif %}
            {% if p == page %}
            <button style="padding: 0.25rem 0.5rem; margin: 0; font-weight: bold;">{{ p }}</button>
            {% else %}
            <a href="{{ base_url }}{{ p }}" role="button" class="outline" style="padding: 0.25rem 0.5rem; margin: 0;">{{ p }}</a>
            {% endif %}
            {% set prev_page.value = p %}
        {% endfor %}

        {# Next and Last buttons #}
        {% if page < total_pages %}
        <a href="{{ base_url }}{{ page + 1 }}" role="button" class="outline" style="padding: 0.25rem 0.5rem; margin: 0;">Next &rarr;</a>
        <a href="{{ base_url }}{{ total_pages }}" role="button" class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" title="Last page">Last</a>
        {% else %}
        <button class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" disabled>Next &rarr;</button>
        <button class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" disabled>Last</button>
        {% endif %}
    </div>

    <!-- Go to page input -->
    <div style="display: flex; align-items: center; gap: 0.5rem;">
        <label style="margin: 0; font-size: 0.875rem;">Page:</label>
        <input type="number" id="gotoPageInput" min="1" max="{{ total_pages }}" value="{{ page }}"
               style="width: 4rem; padding: 0.25rem 0.5rem; margin: 0;">
        <span style="font-size: 0.875rem;">of {{ total_pages }}</span>
        <button class="outline" style="padding: 0.25rem 0.5rem; margin: 0;" onclick="gotoPage()">Go</button>
    </div>
    {% endif %}
</nav>
{% endif %}
{% endblock %}

{% block scripts %}
<script>
// Build URL with current query params
function buildPageUrl(pageNum) {
    const params = new URLSearchParams(window.location.search);
    params.set('page', pageNum);
    return '?' + params.toString();
}

// Polling state
let pollingInterval = null;

// Initialize: Apply stored per_page preference and load retranscribe info
document.addEventListener('DOMContentLoaded', function() {
    const storedPerPage = localStorage.getItem('cast2md_per_page');
    const currentPerPage = {{ per_page }};
    const params = new URLSearchParams(window.location.search);

    // If there's a stored preference and it's not already applied via URL
    if (storedPerPage && !params.has('per_page') && parseInt(storedPerPage) !== currentPerPage) {
        params.set('per_page', storedPerPage);
        params.delete('page'); // Reset to page 1 when changing per_page
        window.location.search = params.toString();
    }

    // Load retranscription info
    loadRetranscribeInfo({{ feed.id }});

    // Start polling if there are queued/processing episodes
    startStatusPolling();
});

// Poll for episode status updates
async function pollEpisodeStatus() {
    // Get currently visible episode IDs from the DOM
    const visibleIds = Array.from(document.querySelectorAll('.episode-checkbox')).map(cb => parseInt(cb.value));
    if (visibleIds.length === 0) return;

    try {
        // Fetch enough episodes to cover all visible ones
        const response = await fetch(`/api/feeds/{{ feed.id }}/episodes?limit=${Math.max(visibleIds.length, 50)}`);
        if (!response.ok) return;

        const data = await response.json();
        const episodeMap = new Map(data.episodes.map(ep => [ep.id, ep]));
        let hasActiveJobs = false;

        for (const epId of visibleIds) {
            const ep = episodeMap.get(epId);
            if (!ep) continue;

            const row = document.querySelector(`tr input[value="${epId}"]`)?.closest('tr');
            if (!row) continue;

            const progressDots = row.querySelector('.progress-dots');
            const currentStatus = progressDots?.dataset.status || '';

            // Check if status changed
            // Update unless we show 'queued' and API still shows 'new' (job not started yet)
            if (currentStatus !== ep.status) {
                if (!(currentStatus === 'queued' && ep.status === 'new')) {
                    updateEpisodeRow(row, ep);
                }
            }

            // Track if there are still active jobs (only downloading/transcribing need polling)
            if (['downloading', 'transcribing'].includes(ep.status) ||
                currentStatus === 'queued') {
                hasActiveJobs = true;
            }
        }

        // Stop polling if no active jobs
        if (!hasActiveJobs && pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
        }
    } catch (error) {
        console.error('Polling error:', error);
    }
}

function getProgressDots(status) {
    const dots = {
        'new': '<span class="dot dot-empty">○</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>',
        'queued': '<span class="dot dot-half">◐</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>',
        'awaiting_transcript': '<span class="dot dot-half">◐</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>',
        'needs_audio': '<span class="dot dot-done">●</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>',
        'downloading': '<span class="dot dot-done">●</span><span class="dot dot-half">◐</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>',
        'audio_ready': '<span class="dot dot-done">●</span><span class="dot dot-done">●</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>',
        'transcribing': '<span class="dot dot-done">●</span><span class="dot dot-done">●</span><span class="dot dot-half">◐</span><span class="dot dot-empty">○</span>',
        'completed': '<span class="dot dot-done">●</span><span class="dot dot-done">●</span><span class="dot dot-done">●</span><span class="dot dot-done">●</span>',
        'failed': '<span class="dot dot-done">●</span><span class="dot dot-fail">✗</span><span class="dot dot-empty">○</span><span class="dot dot-empty">○</span>'
    };
    return dots[status] || dots['new'];
}

function getStatusTooltip(status) {
    const tooltips = {
        'new': 'Ready to process',
        'queued': 'Job queued, waiting to start',
        'awaiting_transcript': 'Checking for external transcript',
        'needs_audio': 'No external transcript - audio download required',
        'downloading': 'Downloading audio...',
        'audio_ready': 'Audio ready, waiting for transcription',
        'transcribing': 'Transcribing with Whisper...',
        'completed': 'Transcript available',
        'failed': 'Processing failed'
    };
    return tooltips[status] || status;
}

function updateEpisodeRow(row, ep) {
    const progressDots = row.querySelector('.progress-dots');
    const actionsCell = row.querySelector('.actions');
    const checkbox = row.querySelector('.episode-checkbox');
    const wasQueued = row.dataset.isQueued === 'true';

    // Determine if this is a "queued" state (job is running but episode status is still new)
    // This happens for fast transcript downloads
    const isQueued = wasQueued && ep.status === 'new';
    const displayStatus = isQueued ? 'queued' : ep.status;

    // Update progress dots
    if (progressDots) {
        progressDots.dataset.status = displayStatus;
        progressDots.title = getStatusTooltip(displayStatus);
        progressDots.innerHTML = getProgressDots(displayStatus);
        if (!isQueued) {
            row.dataset.isQueued = 'false';
        }
    }

    // Update actions based on new status
    if (isQueued) {
        actionsCell.innerHTML = '<span class="actions-spacer"></span>';
        if (checkbox) checkbox.disabled = true;
    } else if (ep.status === 'new') {
        actionsCell.innerHTML = `<button class="outline secondary" onclick="downloadEpisode(${ep.id})">Download Audio</button>`;
        if (checkbox) checkbox.disabled = false;
    } else if (ep.status === 'awaiting_transcript') {
        actionsCell.innerHTML = `<button class="outline secondary" onclick="downloadEpisode(${ep.id})" title="Transcript not ready yet - download audio for Whisper instead">Download Audio</button>`;
        if (checkbox) checkbox.disabled = true;
    } else if (ep.status === 'needs_audio') {
        actionsCell.innerHTML = `<button class="outline secondary" onclick="downloadEpisode(${ep.id})" title="No external transcript available - use Whisper">Download Audio</button>`;
        if (checkbox) checkbox.disabled = true;
    } else if (ep.status === 'audio_ready') {
        actionsCell.innerHTML = `<button class="outline secondary" onclick="transcribeEpisode(${ep.id}, this)">Transcribe</button>`;
        if (checkbox) checkbox.disabled = true;
    } else if (ep.status === 'completed') {
        actionsCell.innerHTML = `<a href="/episodes/${ep.id}" class="outline secondary" role="button">View</a>`;
        if (checkbox) checkbox.disabled = true;
    } else if (ep.status === 'failed') {
        actionsCell.innerHTML = `<button class="outline secondary" onclick="retryEpisode(${ep.id})">Retry</button>`;
        if (checkbox) checkbox.disabled = true;
    } else {
        // downloading, transcribing - spacer to maintain row height
        actionsCell.innerHTML = '<span class="actions-spacer"></span>';
        if (checkbox) checkbox.disabled = true;
    }
}

function startStatusPolling() {
    if (pollingInterval) return; // Already polling
    pollingInterval = setInterval(pollEpisodeStatus, 2000); // Poll every 2 seconds
}

async function loadRetranscribeInfo(feedId) {
    try {
        const response = await fetch(`/api/queue/retranscribe/info/${feedId}`);
        const data = await response.json();

        if (response.ok && data.needs_retranscription > 0) {
            document.getElementById('retranscribeSection').style.display = 'flex';
            document.getElementById('retranscribeInfo').textContent =
                `${data.needs_retranscription} episode(s) can be updated to "${data.current_model}"`;
        }
    } catch (error) {
        console.error('Failed to load retranscribe info:', error);
    }
}

async function batchRetranscribe(feedId) {
    const infoText = document.getElementById('retranscribeInfo').textContent;
    if (!await showConfirm(`Re-transcribe all outdated episodes? ${infoText}. This will replace existing transcripts.`, 'Re-transcribe All')) {
        return;
    }

    try {
        const response = await fetch(`/api/queue/batch/feed/${feedId}/retranscribe`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            setTimeout(() => window.location.reload(), 1500);
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

// Update export link when format changes
document.getElementById('exportFormat').addEventListener('change', function() {
    const format = this.value;
    document.getElementById('exportLink').href = `/api/feeds/{{ feed.id }}/export?format=${format}`;
});

// Per-page selector change
document.getElementById('perPageSelect').addEventListener('change', function() {
    const perPage = this.value;
    localStorage.setItem('cast2md_per_page', perPage);

    const params = new URLSearchParams(window.location.search);
    params.set('per_page', perPage);
    params.delete('page'); // Reset to page 1 when changing per_page
    window.location.search = params.toString();
});

// Go to specific page
function gotoPage() {
    const input = document.getElementById('gotoPageInput');
    const pageNum = parseInt(input.value);
    const totalPages = {{ total_pages }};

    if (pageNum >= 1 && pageNum <= totalPages) {
        window.location.href = buildPageUrl(pageNum);
    } else {
        showError(`Please enter a page number between 1 and ${totalPages}`);
    }
}

// Handle Enter key on goto page input
document.getElementById('gotoPageInput')?.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        gotoPage();
    }
});

async function saveFeedTitle(event) {
    event.preventDefault();
    const customTitle = document.getElementById('customTitleInput').value.trim();

    try {
        const response = await fetch(`/api/feeds/{{ feed.id }}`, {
            method: 'PATCH',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({custom_title: customTitle || null})
        });

        if (response.ok) {
            window.location.reload();
        } else {
            const data = await response.json();
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

// Delete confirmation input handler
document.getElementById('deleteConfirmInput').addEventListener('input', function() {
    document.getElementById('deleteConfirmBtn').disabled = this.value.toLowerCase() !== 'delete';
});

// Reset input when dialog closes
document.getElementById('deleteFeedDialog').addEventListener('close', function() {
    document.getElementById('deleteConfirmInput').value = '';
    document.getElementById('deleteConfirmBtn').disabled = true;
});

async function confirmDeleteFeed() {
    document.getElementById('deleteFeedDialog').close();

    try {
        const response = await fetch(`/api/feeds/{{ feed.id }}`, {method: 'DELETE'});
        const data = await response.json();

        if (response.ok) {
            window.location.href = '/';
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function refreshFeed(feedId) {
    try {
        const response = await fetch(`/api/feeds/${feedId}/refresh`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            setTimeout(() => window.location.reload(), 1500);
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function tryTranscript(episodeId, button) {
    // Immediately update UI to show queued state
    const row = button.closest('tr');
    const progressDots = row.querySelector('.progress-dots');

    button.disabled = true;
    button.textContent = 'Queuing...';

    try {
        const response = await fetch(`/api/queue/episodes/${episodeId}/transcript-download`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            // Update progress dots
            progressDots.dataset.status = 'queued';
            progressDots.title = getStatusTooltip('queued');
            progressDots.innerHTML = getProgressDots('queued');
            row.dataset.isQueued = 'true';
            // Keep button disabled to prevent layout jump
            button.disabled = true;
            button.textContent = '...';
            // Start polling to see when it completes
            startStatusPolling();
        } else {
            // Restore button on error
            button.disabled = false;
            button.textContent = 'Get Transcript';
            showError(data.detail);
        }
    } catch (error) {
        button.disabled = false;
        button.textContent = 'Get Transcript';
        showError(error.message);
    }
}

async function downloadEpisode(episodeId) {
    try {
        // Use queue endpoint instead of synchronous download
        const response = await fetch(`/api/queue/episodes/${episodeId}/process`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            setTimeout(() => window.location.reload(), 1500);
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function transcribeEpisode(episodeId, button) {
    const row = button.closest('tr');
    const progressDots = row.querySelector('.progress-dots');

    button.disabled = true;
    button.textContent = 'Queuing...';

    try {
        const response = await fetch(`/api/queue/episodes/${episodeId}/transcribe`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            progressDots.dataset.status = 'queued';
            progressDots.title = getStatusTooltip('queued');
            progressDots.innerHTML = getProgressDots('queued');
            row.dataset.isQueued = 'true';
            button.disabled = true;
            button.textContent = '...';
            startStatusPolling();
        } else {
            button.disabled = false;
            button.textContent = 'Transcribe';
            showError(data.detail);
        }
    } catch (error) {
        button.disabled = false;
        button.textContent = 'Transcribe';
        showError(error.message);
    }
}

async function retryEpisode(episodeId) {
    // For now, just try download again
    await downloadEpisode(episodeId);
}

async function queueAllDownloads(feedId) {
    if (!await showConfirm('Download audio and transcribe all new episodes? This will download audio files and use Whisper for transcription.', 'Download & Transcribe All')) {
        return;
    }

    try {
        const response = await fetch(`/api/queue/batch/feed/${feedId}/process`, {method: 'POST'});
        const data = await response.json();

        if (response.ok) {
            // Update all new rows to show queued status
            document.querySelectorAll('.progress-dots[data-status="new"]').forEach(dots => {
                const row = dots.closest('tr');
                const btn = row.querySelector('.actions button');
                dots.dataset.status = 'queued';
                dots.title = getStatusTooltip('queued');
                dots.innerHTML = getProgressDots('queued');
                row.dataset.isQueued = 'true';
                if (btn) {
                    btn.disabled = true;
                    btn.textContent = '...';
                }
            });
            // Start polling for updates
            startStatusPolling();
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

// Selection management
function toggleSelectAll() {
    const selectAll = document.getElementById('selectAll');
    document.querySelectorAll('.episode-checkbox:not(:disabled)').forEach(cb => {
        cb.checked = selectAll.checked;
    });
    updateSelectedCount();
}

function updateSelectedCount() {
    const selected = document.querySelectorAll('.episode-checkbox:checked').length;
    document.getElementById('selectedCount').textContent = selected;
    document.getElementById('queueSelectedBtn').style.display = selected > 0 ? 'inline-block' : 'none';
}

async function queueSelected() {
    const selected = Array.from(document.querySelectorAll('.episode-checkbox:checked'))
        .map(cb => parseInt(cb.value));

    if (selected.length === 0) {
        showError('No episodes selected');
        return;
    }

    if (!await showConfirm(`Queue ${selected.length} selected episode(s) for processing?`, 'Queue Selected')) {
        return;
    }

    try {
        const response = await fetch('/api/queue/batch/episodes', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({episode_ids: selected})
        });
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            setTimeout(() => window.location.reload(), 1500);
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function queueByPosition(feedId) {
    const posFrom = document.getElementById('posFrom').value;
    const posTo = document.getElementById('posTo').value;

    if (!posFrom && !posTo) {
        showError('Please specify at least one position value');
        return;
    }

    const rangeDesc = posFrom && posTo ? `episodes ${posFrom}-${posTo}` :
                      posFrom ? `episodes from position ${posFrom}` :
                      `episodes up to position ${posTo}`;

    if (!await showConfirm(`Queue ${rangeDesc} for processing?`, 'Queue by Position')) {
        return;
    }

    try {
        const response = await fetch('/api/queue/batch/range', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                feed_id: feedId,
                position_from: posFrom ? parseInt(posFrom) : null,
                position_to: posTo ? parseInt(posTo) : null
            })
        });
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            setTimeout(() => window.location.reload(), 1500);
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}

async function queueByDate(feedId) {
    const dateFrom = document.getElementById('dateFrom').value;
    const dateTo = document.getElementById('dateTo').value;

    if (!dateFrom && !dateTo) {
        showError('Please specify at least one date');
        return;
    }

    const rangeDesc = dateFrom && dateTo ? `episodes from ${dateFrom} to ${dateTo}` :
                      dateFrom ? `episodes from ${dateFrom}` :
                      `episodes up to ${dateTo}`;

    if (!await showConfirm(`Queue ${rangeDesc} for processing?`, 'Queue by Date')) {
        return;
    }

    try {
        const response = await fetch('/api/queue/batch/range', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                feed_id: feedId,
                date_from: dateFrom || null,
                date_to: dateTo || null
            })
        });
        const data = await response.json();

        if (response.ok) {
            showSuccess(data.message);
            setTimeout(() => window.location.reload(), 1500);
        } else {
            showError(data.detail);
        }
    } catch (error) {
        showError(error.message);
    }
}
</script>
{% endblock %}
